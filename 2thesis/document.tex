% !TEX TS-program = xelatex

% Inicializace tulthesis
\documentclass[FM,DP]{tulthesis}
% Typografie pro češtinu; xelatex alternativa pro babel
\usepackage{polyglossia}
\setdefaultlanguage{czech}
% Angličtina pro abstrakt
\makeatletter
\ExplSyntaxOn
\pretocmd\xpg@set@alias@values{%
	\prop_if_exist:cF { xpg@alias@keyvals@#1@#4 }
	{ \prop_new:c {xpg@alias@keyvals@#1@#4} }
}{}{}
\ExplSyntaxOff
\makeatother
\setotherlanguage{english}
% Automatické pevné mezery
\usepackage{xevlna}
% Zabránění vdov a sirotků
\usepackage[all]{nowidow}
% Snížit šanci na rozdělení posledního slova odstavce
\finalhyphendemerits=200000
% Díky balíku caption kliknutí na \ref odkazující na obrázek skočí opravdu na obrázek, a ne na popisek pod ním
\usepackage{caption}
% Tabulky
\usepackage{enumitem} % Umožní prostředí NiceTabular používat vlastní footnotes
\usepackage{nicematrix} % Posyktuje prostředí NiceTabular

% Zdrojové kódy (konfigurace je v externím souboru, který je sem vložen)
\input{code/code}

% Pro seznam použité literatury
\usepackage[backend=biber, style=iso-numeric]{biblatex}
\addbibresource{zdroje.bib}
% Poslední dva autory knihy neoddělovat středníkem, ale písmenem 'a'
\DeclareDelimFormat{finalnamedelim}{\addspace a\space}

% Název práce
\TULtitle{Grafické uživatelské rozhraní v režimu okamžitého vykreslování}{Graphical user interface in immediate rendering mode}

% -- Prozatimní úvodní stránka --
\TULprogramme{N0613A140028}{Informační technologie}{Information technology}
\TULbranch{}{Aplikovaná informatika}{Applied Informatics}
\TULauthor{Radek Mocek}
\TULsupervisor{Ing. Jiří Jeníček, Ph.D.}
\TULyear{2025}
% --- --- --- --- --- --- --- ---

% Začátek dokumentu
\begin{document}
	
	\ThesisStart{male} % Prozatimní úvodní stránka
	% Úvodní stránky ze STAGu
	%\ThesisStart{vskp_-_zadani_vskp.pdf}	
	
	% Poděkování
	\begin{acknowledgement}
		Děkuji.
	\end{acknowledgement}
	
	% Abstrakt česky
	\begin{abstractCZ}
		Abstrakt česky.
	\end{abstractCZ}
	
	% Klíčová slova česky
	\begin{keywordsCZ}
		Klíčová, slova, česky.
	\end{keywordsCZ}
	\clearpage
	
	% Abstrakt anglicky
	\begin{abstractEN}		
		\begin{english}
			English abstract.
		\end{english}
	\end{abstractEN}
	
	% Klíčová slova anglicky
	\begin{keywordsEN}
		\begin{english}English, keywords.\end{english}
	\end{keywordsEN}
	
	% Obsah
	\tableofcontents
	
	% Seznam obrázků
	\listoffigures
	
	% Seznam tabulek
	\listoftables
	
	% Seznam zdrojových kódů
	\listofcodes
	
	\clearpage
	
	% Zkratky
	
	\newenvironment{abbrList2}{\phantomsection
		{\section*{Seznam zkratek}\addcontentsline{toc}{section}{Seznam zkratek}}
		\noindent\tabularx{\linewidth}{@{}lX@{}}}
	{\endtabularx
		\clearpage}
	
	\begin{abbrList2}
		\textbf{API} & application programming interface, rozhraní pro programování aplikací \\
		\textbf{GUI} & graphical user interface, grafické uživatelské rozhraní \\
		\textbf{IMGUI} & immediate mode graphical user interface, grafické uživatelské rozhraní v režimu okamžitého vykreslování \\
		\textbf{MVVM} & model–view–viewmodel, architektonický vzor \\
		\textbf{RMGUI} & retained mode graphical user interface, grafické uživatelské rozhraní v režimu soběstačného vykreslování \\
		\textbf{WPF} & Windows Presentation Foundation, knihovna umožňující tvorbu GUI aplikací pro operační systém Windows \\
	\end{abbrList2}
	
	% Jádro zprávy
	\chapter{Úvod}
	
	Úvod
	
	\chapter{Grafické uživatelské rozhraní v režimu okamžitého vykreslování}
	
	Grafické uživatelské rozhraní v režimu okamžitého vykreslování (\textit{immediate mode graphical user interface}, zkráceně IMGUI) je specifický přístup k programování aplikačního softwaru s grafickým uživatelským rozhraním. Základní koncept tohoto přístupu veřejně představil Casey Muratori v roce 2005 a s podobnou myšlenkou pracoval i Thierry Excoffier v roce 2003 \cite{report_zeromemorywidgets}. Definice IMGUI není příliš komplexní ani striktní, a proto se postupem času začaly objevovat různé úhly pohledu a interpretace toho, co by „okamžitý režim“ v kontextu vývoje GUI aplikací měl a neměl znamenat. \cite{online_casey}
	
	Autor přístupu IMGUI využil pro jeho pojmenování přívlastek „okamžitý“ z důvodu určité podobnosti k režimu okamžitého vykreslování v některých grafických API té doby \cite{online_casey}. Příkladem může být Direct3D, grafické API od společnosti Microsoft, které mohlo dříve pracovat ve dvou režimech: soběstačný (\textit{retained}) a okamžitý (\textit{immediate}). Z pohledu abstrakce je soběstačný režim na vyšší úrovni, kdy si knihovna interně uchovává model 3D scény a od aplikačního kódu přijímá příkazy, které manipulují s objekty v této scéně. Pro vykreslení snímku pak knihovna transformuje informace o objektech ve scéně na sadu příkazů pro vykreslování. V okamžitém režimu se s modelem scény pracuje na straně aplikačního kódu a knihovna přijímá až samotné příkazy pro vykreslování. Tím sice narůstá počet úkonů, které musí být provedeny na straně aplikačního kódu, zároveň se ale zvětšuje flexibilita a prostor pro optimalizace. \cite{book_direct3dbible, online_direct2d}
	
	% [? Diagram IM vs RM, případně diagram dobového Direct3D ?]
	
	Podobně lze nahlížet na programování GUI aplikací. Běžně používané knihovny, které tvorbu GUI aplikací umožňují, jsou v této analogii chápány jako soběstačný režim a přísluší jim zkratka RMGUI (\textit{retained mode graphical user interface}). S využitím těchto knihoven definuje aplikační kód jednotlivé ovládací prvky, u kterých obvykle specifikuje jejich identifikátory, vzájemné rozložení, a případné callback metody. Knihovna pak ve své interní smyčce řeší vykreslování ovládacích prvků a reakce na události. Mezi zástupce tohoto přístupu patří např. knihovny Qt a WPF. Oproti tomu aplikační kód, který využívá knihovnu s přístupem IMGUI, neobsahuje žádnou inicializační fázi, kde by se definovaly jednotlivé ovládací prvky, ani callback metody, které by reagovaly na určité události. Aplikační kód zde definuje pouze hlavní smyčku, která obsahuje jak příkazy pro vykreslování ovládacích prvků, tak reakce na případné události. Definice přístupu IMGUI explicitně zmiňuje pouze tento rozdíl z pohledu programátora koncové aplikace, implementace samotných knihoven mohou být různé. \cite{online_casey}
	
	\section{Demonstrace rozdílu mezi přístupy RMGUI a IMGUI}\label{Chapter2SectionHelloCounter}
	
	Rozdíl mezi přístupy RMGUI a IMGUI je dobře vidět na ukázce aplikačního kódu. Pro demonstraci byl zvolen jednoduchý program, který dokáže čítat od jedné do pěti a pozdravit uživatele. Program obsahuje jednu stavovou proměnnou, která reprezentuje stav čítače a její výchozí hodnota je rovna jedné. Dále program obsahuje čtyři ovládací prvky: dvě tlačítka a dva textové popisky. Jeden textový popisek vždy zobrazuje hodnotu čítače. Druhý popisek zobrazuje pozdrav v podobě řetězce „\textit{Hello!}“, je ale viditelný pouze v případě, kdy je hodnota čítače rovna třem.
	
	Tlačítka jsou označena symboly „$+$“ a „$-$“. Po kliknutí na tlačítko se symbolem „$+$“ se přičte jednička k hodnotě čítače a kliknutím na tlačítko se symbolem „$-$“ se jednička naopak odečte. Jelikož se má čítat pouze od jedné do pěti, tak je tlačítko se symbolem „$-$“ neaktivní v případě, kdy je hodnota čítače rovna jedné. Podobné pravidlo platí pro tlačítko se symbolem „$+$“, které je neaktivní zase tehdy, pokud je hodnota čítače rovna pěti.
	
	Z důvodu zvýšení přehlednosti neobsahují ukázky logiku pro nastavení vzhledu a rozmístění ovládacích prvků, je zde pouze to důležité pro pochopení principu daného přístupu. Kód \ref{_tag_code_HelloCounterQt} představuje přístup RMGUI v knihovně Qt. Metoda \texttt{init} obsahuje logiku inicializační fáze, která postupně nastaví čtyři ovládaní prvky a stavovou proměnnou. Všechny ovládací prvky jsou vytvořeny a přidány do rozložení hlavního okna, které je reprezentované proměnnou \texttt{layout}. U tlačítek je pomocí funkce \texttt{connect} nastavena jejich callback metoda, která se volá po kliknutí na dané tlačítko. Nakonec je čítač nastaven na svou výchozí hodnotu a volá se metoda \texttt{on\_counter\_update}, která zajistí, aby textové popisky a stav tlačítek (zdali jsou nebo nejsou aktivní) odpovídaly aktuální hodnotě čítače. Callback metody upravují hodnotu čítače, a následně opět volají metodu \texttt{on\_counter\_update}. Všechny čtyři ovládací prvky v této ukázce jsou dynamické, a proto se musí jednat o členy třídy \texttt{App}, aby k nim bylo možné přistupovat z callback metod.
	
	Kód \ref{_tag_code_HelloCounterImGui} představuje přístup IMGUI v knihovně \textit{Dear ImGui}. Metoda \texttt{update} obsahuje logiku hlavní smyčky, která je obvykle volána se stejnou frekvencí, jako je obnovovací frekvence zobrazovacího zařízení. Nejprve je čítač nastaven na svou výchozí hodnotu, kterou si díky klíčovému slovu \texttt{static} drží i při opakovaném volání metody. Vybraná knihovna se chová jako stavový automat, což je vidět na kódu, který následuje: po zavolání metody \texttt{Begin($x$)} je vytvořeno okno s názvem $x$ a všechny další příkazy se provádí relativně k tomuto oknu, dokud není zavolána metoda \texttt{End}. To samé platí pro dvojici metod \texttt{BeginDisabled($p$)} a \texttt{EndDisabled}. Je-li  splněna podmínka $p$, pak jsou veškeré ovládací prvky, jejichž vykreslení je definováno mezi voláními těchto dvou metod, označeny jako neaktivní. Metoda \texttt{Button} říká, že má být vykresleno dané tlačítko, a zároveň vrací pravdivostní hodnotu, která vyjadřuje, zdali bylo tlačítko stisknuto. Metoda \texttt{Text} pak vykresluje textové popisky. Oproti přístupu RMGUI, kde se u objektu pod správou knihovny Qt, který reprezentuje textové pole s pozdravem, přepíná parametr viditelnosti, je v přístupu IMGUI vykreslení textu jednoduše podmíněno.
	
	% [? Obrázek HelloCounter ?]
	
	% <? Zde by mohla být přidána sekce nastiňující jak to funguje pod kapotou (IMGUI vs RMGUI) ?>
	
	Z rozdílů mezi řešeními pomocí RMGUI a IMGUI, které byly představeny v této ukázce, vyplývají některé přednosti a úskalí obou přístupů. Nejprve je ale třeba zmínit, že problematika není takto černobílá. Jednotlivé architektury a knihovny se mohou lišit v drobných detailech, kombinovat oba přístupy, nebo problém řešit přístupem zcela odlišným. Např., oproti zde představenému řešení v knihovně Qt, by v architektuře MVVM mohla být hodnota textového popisku svázána přímo s proměnnou reprezentující hodnotu čítače. Při jakékoliv změně proměnné \texttt{counter} by se pak hodnota popisku \texttt{label\_counter\_value} aktualizovala automaticky.
	
	Vzdálenějším příkladem jsou knihovny pro tvorbu GUI v jazyce JavaScript, jako je např. React. Zde si knihovna obvykle uchovává strom programátorem definovaných komponent ve stylu soběstačného režimu. Z pohledu aplikačního kódu se pak ale logika jednotlivých komponent místy podobá spíše režimu okamžitému. \cite{online_hybridui}
	
	\section{Důsledky přístupu IMGUI}
	
	Výhody přístupu IMGUI se projevují především při psaní aplikačního kódu. Knihovna neustále přijímá příkazy pro vykreslování samotných ovládacích prvků, a díky tomu si nemusí uchovávat jejich stav. Toto platí alespoň z pohledu programátora koncové aplikace. Nemusí to nutně znamenat, že si knihovna pracující v okamžitém režimu nemůže o ovládacích prvcích uchovávat žádná data \cite{online_imguiwiki}.
	
	Příkladem myšleného stavu u tlačítka může být jeho textový popisek, nebo informace o tom, zdali je tlačítko aktivní. Tento stav je tlačítku předán v každém průchodu hlavní smyčkou jako součást volání příkazů pro jeho vykreslení. Všechny stavové hodnoty jsou uloženy a spravovány pouze na straně aplikačního kódu, a není proto nutné je synchronizovat se stavem, který by si udržovala knihovna.
	
	To, že všechna důležitá data vlastní pouze aplikační kód, vede společně s absencí callback metod na styl kódu, který je oproti přístupu RMGUI kratší a umožňuje držet související logiku více pohromadě. Vlastnost kratšího kódu se projevuje především u dynamických uživatelských rozhraní, kdy je možné měnit stav a existenci ovládacích prvků s každým průchodem hlavní smyčky.
	
	Z hlediska programování samotných knihoven přicházejí s přístupem IMGUI určité implementační výzvy. Překreslování statického GUI šedesátkrát (nebo i vícekrát) za vteřinu by zbytečně zatěžovalo zařízení, a proto je vhodné, aby knihovna dokázala překreslovat jen ty ovládací prvky, které se od minulého průchodu změnily. To znamená, že i když to knihovna nedává nijak najevo, musí si o vykreslovaných ovládacích prvcích interně udržovat určité informace, které přetrvají déle než jeden průchod hlavní smyčkou.
	
	Udržovat si určité informace je potřeba i z důvodu podpory komplexnějšího rozložení ovládacích prvků. Jednoduchým příkladem je nemodální dialogové okno, které si automaticky určuje svou velikost podle svého obsahu. Je-li jeho obsahem jeden textový popisek, pak počet řádků tohoto popisku určuje výšku celého dialogového okna. Chová-li se knihovna jako stavový automat, pak je nejprve potřeba vykreslit dialogové okno, a až poté relativně k němu vykreslit textový popisek. Pokud by se o ovládacích prvcích neuchovávala žádná data, pak by v době vykreslování dialogového okna nebyla existence textového popisku, který se v něm nachází, vůbec známa. Problému nenapomáhá ani fakt, že textový popisek může být dynamický a měnit tak svůj obsah každý snímek.
	
	Řešením může být uchovávání velikosti textového popisku z předchozích iterací, kde je předpoklad takový, že velikost popisku v aktuální iteraci je stejná, jako byla v iteraci předchozí. Změna velikosti textového popisku se s tímto přístupem projeví na velikosti rodičovského okna se zpožděním minimálně jednoho snímku. Alternativně lze pro každý vykreslený snímek projít hlavní smyčkou dvakrát, kdy první průchod řeší korektní rozložení ovládacích prvků, a druhý průchod pak řeší jejich vykreslení a reakce na události. Dále je možné přidat logiku, která určuje, zdali je pro další snímek nutné projít hlavní smyčkou dvakrát, nebo jen jednou. \cite{online_casey, online_eguidocs}
	
	Obrázek \ref{_tag_img_MicroUiAutosizeDelay}	ukazuje šest po sobě jdoucích snímků aplikace, která s využitím knihovny \textit{microui} vykresluje dvě okna. Vrchní okno, které na začátku obsahuje dva řádky textu, má nastaven příznak \texttt{MU\_OPT\_AUTOSIZE}, který říká, že má dané okno automaticky měnit svou velikost podle svého obsahu. Spodní okno obsahuje tlačítko, které po kliknutí přidá do vrchního okna další dva řádky textu, a textový popisek, který zobrazuje číslo aktuálního snímku. V prvním snímku je zaregistrováno kliknutí na tlačítko. V druhém snímku už vrchní okno obsahuje čtyři řádky textu, které ale v tu chvíli ještě nejsou vidět. Velikost vrchního okna je ustálena až na snímku číslo šest.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=\textwidth]{img/microui_autosize_delay}
		\caption{Zpoždění při aktualizaci okna s automatickou velikostí}
		\label{_tag_img_MicroUiAutosizeDelay}
	\end{figure}
	
	Jak již bylo zmíněno, původní definice IMGUI se zaměřuje hlavně na to, jak má vypadat aplikační kód, který využívá knihovnu poskytující tento přístup. Teoreticky tedy mohou jednotlivé knihovny využívat libovolných technologií. V praxi mají ale všechny jedno společné: pro zobrazování GUI využívají některého z existujících rozhraní pro vykreslování počítačové grafiky, jako je např. OpenGL, Vulkan, nebo DirectX. V terminologii přístupu IMGUI bývá takovéto rozhraní nazýváno \textit{backend}.
	
	Z využití multiplatformního grafického API vyplývá několik vlastností. Výsledná aplikace by měla podporovat všechny platformy, které jsou podporované vybraným backendem, a zároveň bude na všech platformách vypadat stejně. Stejný vzhled na všech platformách nemusí být nutně výhodou. Koncoví uživatelé mohou být zvyklí na to, že jejich aplikace vypadají „nativně“, tedy že využívají ovládacích prvků poskytnutých daným operačním systémem. Díky tomu, že knihovna zobrazuje GUI posíláním příkazů pro vykreslení vybranému backendu, může být vzhled ovládacích prvků výsledné aplikace velmi přizpůsobitelný včetně možnosti snadno jej měnit i za běhu aplikace. To umožňuje mimo jiné imitovat vzhled nativních aplikací.
	
	To, že bude výsledná aplikace vypadat na všech platformách stejně, platí až na tzv. dekorace okna, jejichž vzhled je ovlivněn operačním systémem a desktopovým prostředím. Knihovny s přístupem IMGUI často vykreslují všechny ovládací prvky do jednoho „hostitelského“ okna, které jim poskytuje vybraný backend, a to včetně dialogových oken. Dodatečná okna jsou v tomto případě vykreslována a spravována samotnou knihovnou jako součást hostitelského okna, ze kterého je nelze přesunout „ven“. Nemodální dialogové okno bývá základním stavebním blokem IMGUI knihoven s tím, že pro simulaci hlavního okna aplikace se vytvoří dialogové okno o takové velikosti, aby zabralo celý prostor okna hostitelského. U tohoto hlavního okna je nastaveno, aby bylo vždy na pozadí, nevykreslovalo své záhlaví apod.
	
	Obrázek \ref{_tag_img_HelloCounterImguiQtWinLin} ukazuje čtyři instance demonstrační aplikace popsané v sekci \ref{Chapter2SectionHelloCounter}, která zde navíc zobrazuje dialogové okno. U instancí implementovaných v knihovně Qt (sloupec vpravo) není dialogové okno součástí okna hlavního, a proto jej lze přesunout na libovolné místo. Zároveň je ale vzhled okna závislý na vybrané platformě.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=.75\textwidth]{img/imgui_qt_win10_plasma}
		\caption{Knihovny Dear Imgui a Qt v prostředích Windows 10 a KDE Plasma}
		\label{_tag_img_HelloCounterImguiQtWinLin}
	\end{figure}
	
	Vzhled aplikace není jediná vlastnost, na kterou mohou být uživatelé zvyklí. Dalším příkladem může být horní lišta nabídek (\textit{menu bar}), u které se očekává možnost navigace pomocí klávesových zkratek. Ne každá aplikace sice potřebuje disponovat lištou nabídek, každopádně její případné zobrazení je např. v knihovně Qt záležitostí volání jedné metody. U knihoven s přístupem IMGUI toto není zaručeno a logika lišty nabídek musí být explicitně implementována buď ze strany knihovny, nebo až v aplikačním kódu. Totéž platí např. pro nastavení přístupnosti, jako je respektování velikosti písma nastavené v rámci operačního systému nebo podpora odečítače obrazovky.
	
	Knihovny s přístupem IMGUI se často používají pro přidání ovládacích prvků do existující interaktivní aplikace, která využívá stejný backend. Taková aplikace už má definovanou svou vykreslovací smyčku, do které lze snadno přidat příkazy pro vykreslování GUI. To je jeden z důvodů, proč bývá u těchto knihoven základním stavebním prvkem právě nemodální dialogové okno. Tato okna jsou vykreslována nad existující interaktivní aplikací, která o nich v podstatě „neví“, a obsahují např. ovládací prvky pro ladění nebo změnu určitých parametrů za běhu.
	
	% <?
	% * Prázdná Qt aplikace využívá ~10 MB RAM; Dear ImGui ~100 MB, nebo 20 MB? (jak vůastně správně benchmarkovat ?)
	% * Problematika renderování fontů (v OpenGL)
	% * Implementační jazyky obvykle low level
	% * Možnost změny backendu; Emscripten→web
	% * Proč Microui trvá 5 snímků "nastavit" správnou velikost okna?
	% ?>
	
	\section{Existující knihovny pro tvorbu GUI aplikací s přístupem IMGUI}
	
	I přes to, že přístup IMGUI je poměrně starý koncept a na poli tvorby „běžných“ GUI aplikací dominuje přístup RMGUI, jsou některé IMGUI knihovny stále ve vývoji a nachází svá uplatnění.	Tabulka \ref{_tag_table_libraries} představuje knihovny, které jsou součástí této rešerše. Existuje mnoho projektů, které nějakým způsobem využívají knihovnu Dear ImGui ve smyslu, že ji buď rozšiřují, nebo převádí do ekosystému jiného programovacího jazyka. Tato rešerše se soustředí na knihovny, které přichází s kompletně vlastním řešením. Kromě projektu microui, který měl poslední aktualizaci v srpnu roku 2024, jsou v době psaní této rešerše všechny knihovny v aktivním vývoji.
		
	\begin{table}[ht]
		\centering
		\caption{Přehled knihoven pro tvorbu GUI aplikací s přístupem IMGUI}
		\begin{NiceTabular}{ l l l c r }[cell-space-limits=3pt]
			\CodeBefore
				\rowcolors[gray]{2}{0.95}{}
			\Body
				\RowStyle{\bfseries}
					Název & Jazyk & Licence & Vznik & Popularita\tabularnote[$\star$]{počet hvězd na platformě GitHub ke dni 12. 11. 2025} \\
				\hline
					Dear ImGui  & C++  & MIT             & 2014 & 69 315 \\
					egui        & Rust & MIT, Apache-2.0 & 2018 & 27 111 \\
					Nuklear     & C    & MIT, Unlicense  & 2015 & 10 554 \\
					microui     & C    & MIT             & 2018 &  5 140 \\
					raygui      & C    & Zlib            & 2014 &  4 437 \\
					Gio         & Go   & MIT, Unlicense  & 2019 &  2 059 \\\RowStyle[cell-space-bottom-limit=1pt]{}
					dvui		& Zig  & MIT			 & 2022 &    993 \\
				\hline
		\end{NiceTabular}
		\label{_tag_table_libraries}
	\end{table}
	
	\subsection{Dear ImGui}
	
	Dear ImGui je knihovna pro tvorbu GUI s přístupem IMGUI napsaná v jazyce C++. Její kód splňuje standard \textit{C++11} a nepoužívá žádné standardní knihovny. Dear ImGui se často využívá ve videoherním průmyslu k tvorbě dynamických nástrojů pro ladění. Knihovna je psaná tak, aby šla snadno integrovat do existujícího projektu s libovolným backendem. Základním stavebním prvkem je tedy nemodální dialogové okno, knihovna ale umožňuje vytvořit takové okno, které nemá žádné dekorace, zůstává na pozadí a zabírá celý prostor okna hostitelského.
	
	\dots\ \dots\ \dots\ \dots\ \dots\ \dots
	
	\cite{online_imguiwiki}
	
	% * neexistuje proper dokumentace, ale example je slušný
	% * extensions jako implot
	
	% * Mrknout na hello imgui a imgui toolkit
	% * Zmínit docking branch
	
	% * Umí měnit kurzor? (myšleno nativní druhy kurzoru, nikoliv vlastní obrázek)
		
	\subsection{egui}
	
	% CtrlF v textu ?
	
	\subsection{Nuklear}
	
	\subsection{microui}
	
	\subsection{raygui}
	
	% * https://github.com/raysan5/rguilayout
	
	\subsection{Gio}
	
	\subsection{dvui}
	
	% Zdroje
	\chapter*{Seznam použité literatury}
	\addcontentsline{toc}{chapter}{Seznam použité literatury}
	\printbibliography[heading=none]
	
	% Přílohy
	\appendix
	\chapter{Ukázkové kódy}
	
	\begin{code}
		\lstinputlisting[language=CppQt]{code/hello_counter_rmgui.cpp}
		\caption{Kód demonstrující přístup RMGUI s využitím knihovny Qt}
		\label{_tag_code_HelloCounterQt}
	\end{code}
	
	\begin{code}
		\lstinputlisting[language=CppImGui]{code/hello_counter_imgui.cpp}
		\caption{Kód demonstrující přístup IMGUI s využitím knihovny Dear ImGui}
		\label{_tag_code_HelloCounterImGui}
	\end{code}
	
\end{document}
