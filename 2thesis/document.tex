% !TEX TS-program = xelatex

% Inicializace tulthesis
\documentclass[FM,DP]{tulthesis}
% Typografie pro češtinu; xelatex alternativa pro babel
\usepackage{polyglossia}
\setdefaultlanguage{czech}
% Angličtina pro abstrakt
\makeatletter
\ExplSyntaxOn
\pretocmd\xpg@set@alias@values{%
	\prop_if_exist:cF { xpg@alias@keyvals@#1@#4 }
	{ \prop_new:c {xpg@alias@keyvals@#1@#4} }
}{}{}
\ExplSyntaxOff
\makeatother
\setotherlanguage{english}
% Automatické pevné mezery
\usepackage{xevlna}
% Zabránění vdov a sirotků
\usepackage[all]{nowidow}
% Snížit šanci na rozdělení posledního slova odstavce
\finalhyphendemerits=200000
% Díky balíku caption kliknutí na \ref odkazující na obrázek skočí opravdu na obrázek, a ne na popisek pod ním
\usepackage{caption}
% Tabulky
\usepackage{enumitem} % Umožní prostředí NiceTabular používat vlastní footnotes
\usepackage{nicematrix} % Posyktuje prostředí NiceTabular

% Zdrojové kódy (konfigurace je v externím souboru, který je sem vložen)
\input{code/code}

% Pro seznam použité literatury
\usepackage[backend=biber, style=iso-numeric]{biblatex}
\addbibresource{zdroje.bib}
% Poslední dva autory knihy neoddělovat středníkem ale písmenem 'a'
\DeclareDelimFormat{finalnamedelim}{\addspace a\space}

% Název práce
\TULtitle{Grafické uživatelské rozhraní v režimu okamžitého vykreslování}{Graphical user interface in immediate rendering mode}

% -- Prozatimní úvodní stránka --
\TULprogramme{N0613A140028}{Informační technologie}{Information technology}
\TULbranch{}{Aplikovaná informatika}{Applied Informatics}
\TULauthor{Radek Mocek}
\TULsupervisor{Ing. Jiří Jeníček, Ph.D.}
\TULyear{2025}
% --- --- --- --- --- --- --- ---

% Začátek dokumentu
\begin{document}
	
	\ThesisStart{male} % Prozatimní úvodní stránka
	% Úvodní stránky ze STAGu
	%\ThesisStart{vskp_-_zadani_vskp.pdf}	
	
	% Poděkování
	\begin{acknowledgement}
		Děkuji.
	\end{acknowledgement}
	
	% Abstrakt česky
	\begin{abstractCZ}
		Abstrakt česky.
	\end{abstractCZ}
	
	% Klíčová slova česky
	\begin{keywordsCZ}
		Klíčová, slova, česky.
	\end{keywordsCZ}
	\clearpage
	
	% Abstrakt anglicky
	\begin{abstractEN}		
		\begin{english}
			English abstract.
		\end{english}
	\end{abstractEN}
	
	% Klíčová slova anglicky
	\begin{keywordsEN}
		\begin{english}English, keywords.\end{english}
	\end{keywordsEN}
	
	% Obsah
	\tableofcontents
	
	% Seznam obrázků
	\listoffigures
	
	% Seznam tabulek
	\listoftables
	
	% Seznam zdrojových kódů
	\listofcodes
	
	\clearpage
	
	% Zkratky
	\begin{abbrList}
		\textbf{API} & application programming interface, rozhraní pro programování aplikací \\
		\textbf{GUI} & graphical user interface, grafické uživatelské rozhraní \\
		\textbf{IMGUI} & immediate mode graphical user interface, grafické uživatelské rozhraní v režimu okamžitého vykreslování \\
		\textbf{MVVM} & model–view–viewmodel, architektonický vzor \\
		\textbf{RMGUI} & retained mode graphical user interface, grafické uživatelské rozhraní v režimu soběstačného vykreslování \\
		\textbf{WPF} & Windows Presentation Foundation, knihovna umožňující tvorbu GUI aplikací pro operační systém Windows \\
	\end{abbrList}
	
	% Jádro zprávy
	\chapter{Úvod}
	
	Úvod
	
	\chapter{Grafické uživatelské rozhraní v režimu okamžitého vykreslování}
	
	Grafické uživatelské rozhraní v režimu okamžitého vykreslování (\textit{immediate mode graphical user interface}, zkráceně IMGUI) je specifický přístup k programování aplikačního softwaru s grafickým uživatelským rozhraním. Základní koncept tohoto přístupu veřejně představil Casey Muratori v roce 2005 a s podobnou myšlenkou pracoval i Thierry Excoffier v roce 2003 \cite{report_zeromemorywidgets}. Definice IMGUI není příliš komplexní ani striktní, a proto se postupem času začaly objevovat různé úhly pohledu a interpretace toho, co by „okamžitý režim“ v kontextu vývoje GUI aplikací měl a neměl znamenat. \cite{online_casey}
	
	Autor přístupu IMGUI využil pro jeho pojmenování přívlastek „okamžitý“ z důvodu určité podobnosti k režimu okamžitého vykreslování v některých grafických API té doby \cite{online_casey}. Příkladem může být Direct3D, grafické API od společnosti Microsoft, které mohlo dříve pracovat ve dvou režimech: soběstačný (\textit{retained}) a okamžitý (\textit{immediate}). Z pohledu abstrakce je soběstačný režim na vyšší úrovni, kdy si knihovna interně uchovává model 3D scény a od aplikačního kódu přijímá příkazy, které manipulují s objekty v této scéně. Pro vykreslení snímku pak knihovna transformuje informace o objektech ve scéně na sadu příkazů pro vykreslování. V okamžitém režimu se s modelem scény pracuje na straně aplikačního kódu a knihovna přijímá až samotné příkazy pro vykreslování. Tím sice narůstá počet úkonů, které musí být provedeny na straně aplikačního kódu, zároveň se ale zvětšuje flexibilita a prostor pro optimalizace. \cite{book_direct3dbible, online_direct2d}
	
	% [? Diagram IM vs RM, případně diagram dobového Direct3D ?]
	
	Podobně lze nahlížet na programování GUI aplikací. Běžně používané knihovny, které tvorbu GUI aplikací umožňují, jsou v této analogii chápány jako soběstačný režim a přísluší jim zkratka RMGUI (\textit{retained mode graphical user interface}). S využitím těchto knihoven definuje aplikační kód jednotlivé ovládací prvky, u kterých obvykle specifikuje jejich identifikátory, vzájemné rozložení, a případné callback metody. Knihovna pak ve své interní smyčce řeší vykreslování ovládacích prvků a reakce na události. Mezi zástupce tohoto přístupu patří např. knihovny Qt a WPF. Oproti tomu aplikační kód, který využívá knihovnu s přístupem IMGUI, neobsahuje žádnou inicializační fázi, kde by se definovaly jednotlivé ovládací prvky, ani callback metody, které by reagovaly na určité události. Aplikační kód zde definuje pouze hlavní smyčku, která obsahuje jak příkazy pro vykreslování ovládacích prvků, tak reakce na případné události. Definice přístupu IMGUI explicitně zmiňuje pouze tento rozdíl z pohledu programátora koncové aplikace, implementace samotných knihoven mohou být různé. \cite{online_casey}
	
	\section{Demonstrace rozdílu mezi přístupy RMGUI a IMGUI}
	
	Rozdíl mezi přístupy RMGUI a IMGUI je dobře vidět na ukázce aplikačního kódu. Pro demonstraci byl zvolen jednoduchý program, který dokáže čítat od jedné do pěti a pozdravit uživatele. Program obsahuje jednu stavovou proměnnou, která reprezentuje stav čítače a její výchozí hodnota je rovna jedné. Dále program obsahuje čtyři ovládací prvky: dvě tlačítka a dva textové popisky. Jeden textový popisek vždy zobrazuje hodnotu čítače. Druhý popisek zobrazuje pozdrav v podobě řetězce „\textit{Hello!}“, je ale viditelný pouze v případě, kdy je hodnota čítače rovna třem.
	
	Tlačítka jsou označena symboly „$+$“ a „$-$“. Po kliknutí na tlačítko se symbolem „$+$“ se přičte jednička k hodnotě čítače a kliknutím na tlačítko se symbolem „$-$“ se jednička naopak odečte. Jelikož se má čítat pouze od jedné do pěti, tak je tlačítko se symbolem „$-$“ neaktivní v případě, kdy je hodnota čítače rovna jedné. Podobné pravidlo platí pro tlačítko se symbolem „$+$“, které je neaktivní zase tehdy, pokud je hodnota čítače rovna pěti.
	
	Z důvodu zvýšení přehlednosti neobsahují ukázky logiku pro nastavení vzhledu a rozmístění ovládacích prvků, je zde pouze to důležité pro pochopení principu daného přístupu. Kód \ref{_tag_code_HelloCounterQt} představuje přístup RMGUI v knihovně Qt. Metoda \texttt{init} obsahuje logiku inicializační fáze, která postupně nastaví čtyři ovládaní prvky a stavovou proměnnou. Všechny ovládací prvky jsou vytvořeny a přidány do rozložení hlavního okna, které je reprezentované proměnnou \texttt{layout}. U tlačítek je pomocí funkce \texttt{connect} nastavena jejich callback metoda, která se volá po kliknutí na dané tlačítko. Nakonec je čítač nastaven na svou výchozí hodnotu a volá se metoda \texttt{on\_counter\_update}, která zajistí, aby textové popisky a stav tlačítek (zdali jsou nebo nejsou aktivní) odpovídaly aktuální hodnotě čítače. Callback metody upravují hodnotu čítače, a následně opět volají metodu \texttt{on\_counter\_update}.
	
	Kód \ref{_tag_code_HelloCounterImGui} představuje přístup IMGUI v knihovně \textit{Dear ImGui}. Metoda \texttt{update} obsahuje logiku hlavní smyčky, která je obvykle volána se stejnou frekvencí, jako je obnovovací frekvence zobrazovacího zařízení. Jako první je nastaven čítač na svou výchozí hodnotu, kterou si díky klíčovému slovu \texttt{static} drží i při opakovaném volání metody. Vybraná knihovna se chová jako stavový automat, což je vidět na kódu, který následuje: po zavolání metody \texttt{Begin($x$)} je vytvořeno okno s názvem $x$ a všechny další příkazy se provádí relativně k tomuto oknu, dokud není zavolána metoda \texttt{End}. To samé platí pro dvojici metod \texttt{BeginDisabled($p$)} a \texttt{EndDisabled}. Je-li  splněna podmínka $p$, pak jsou veškeré ovládací prvky, jejichž vykreslení je definováno mezi voláními těchto dvou metod, označeny jako neaktivní. Metoda \texttt{Button} říká, že má být vykresleno dané tlačítko, a zároveň vrací pravdivostní hodnotu, která vyjadřuje, zdali bylo tlačítko stisknuto. Metoda \texttt{Text} pak vykresluje textové popisky. Oproti přístupu RMGUI, kde se u objektu reprezentujícího textové pole, který je pod správou knihovny Qt, přenastavuje parametr viditelnosti, je zde samotné vykreslení textu s pozdravem podmíněno.
	
	% [? Obrázek HelloCounter ?]
	
	% <? Zde by mohla být přidána sekce nastiňující jak to funguje pod kapotou (IMGUI vs RMGUI) ?>
	
	Z rozdílů mezi řešeními pomocí RMGUI a IMGUI, které byly představeny v této ukázce, vyplývají některé přednosti a úskalí obou přístupů. Nejprve je ale třeba zmínit, že problematika není takto černobílá. Jednotlivé architektury a knihovny se mohou lišit v drobných detailech, kombinovat oba přístupy, nebo problém řešit přístupem zcela odlišným. Např., oproti zde představenému řešení v knihovně Qt, by v architektuře MVVM mohla hodnota textového popisku být svázána přímo s proměnnou reprezentující hodnotu čítače.
	
	Vzdálenějším příkladem jsou knihovny pro tvorbu GUI v jazyce JavaScript, jako je např. React. Zde si knihovna obvykle uchovává strom programátorem definovaných komponent ve stylu soběstačného režimu. Z pohledu aplikačního kódu se pak ale logika jednotlivých komponent místy podobá režimu okamžitému. \cite{online_hybridui}
	
	\section{Důsledky přístupu IMGUI}
	
	Výhody přístupu IMGUI se projevují především při psaní aplikačního kódu. Knihovna neustále přijímá příkazy pro vykreslování samotných ovládacích prvků a díky tomu si nemusí uchovávat jejich stav. Toto platí alespoň z pohledu programátora koncové aplikace. Nemusí to nutně znamenat, že si knihovna pracující v okamžitém režimu nemůže o ovládacích prvcích uchovávat žádná data. Příkladem stavu u tlačítka může být jeho textový popisek, nebo informace o tom, zdali je aktivní. Tento stav je tlačítku předán v každém průchodu hlavní smyčkou jako součást volání příkazu pro jeho vykreslení. Všechny stavové hodnoty jsou tedy uloženy a spravovány pouze na straně aplikačního kódu
	
	% IMGUI:
	% - furt se překresluje → performance
	% - menší reflexe ve smyslu reakce na layout (např. chceme rámeček automatické velikosti určené dle velikosti dětí – problém)
	% - koncept widgetů neexistuje mimo jejich samotné vykreslení, problém opět při auto layout nebo přepínání pomocí tab/alt, ...
	% + minimální stav, eliminace getů a setů z objektů reprezentujících widgety (data is owned by the host application and not the widget)
	% + rychlé, nepříliš ukecané
	% + knihovny mohou být velmi malé; kód začne bobtnat s příchodem optimalizací (cache, vykreslovat jen když je potřeba)?
	% "The widgets only exist when they're called, so you'll need to ask for them each frame you want to use them" → snadno lze dělat velmi proměnlivé UI
	% ~ související věci na jednom místě → význam, logika, design, prezentace se mixují, ale...?
	% ~ není OOP friendly ?
	
	% Na imgui pohlížíme z pohledu api, neznamená to tedy, že imgui knihovna nemůže pod kapotou mít uložený nějaký stav, a nebo že musí překreslovat celé gui každý frame; i přesto jde ale ruku v ruce s realtime aplikacemi. Teoreticky nemusí nutně běžet na nějakém opengl apod., ale v praxi to tak obvykle je, a z toho vyplývá:
	% + Vypadá to na všech platformách stejně (a je to multiplatformní)
	% + Ideální pro kombinaci s dalším řešením využívajícím realtime rendering (unaware components)
	% - Fonty
	% - Koncoví uživatelé jsou zvyklí na "systémově vypadající" aplikace
	% - Podpora čteček a další možnosti přístupnosti nejsou samozřejmostí
	
	\section{Existující knihovny pro tvorbu GUI aplikací s přístupem IMGUI}
	
	% * i když je imgui starý koncept, knihovny jsou stále ve vývoji
		
	\begin{table}[ht]
		\centering
		\caption{Přehled knihoven pro tvorbu GUI aplikací s přístupem IMGUI}
		\begin{NiceTabular}{ l l l c r }[cell-space-limits=3pt]
			\CodeBefore
				\rowcolors[gray]{2}{0.95}{}
			\Body
				\RowStyle{\bfseries}
					Název & Jazyk & Licence & Vznik & Popularita\tabularnote[$\star$]{počet hvězd na platformě GitHub ke dni 3. 11. 2025} \\
				\hline
					Dear ImGui  & C++  & MIT             & 2014 & 69 111 \\
					egui        & Rust & MIT, Apache-2.0 & 2018 & 27 003 \\
					Nuklear     & C    & MIT, Unlicense  & 2015 & 10 530 \\
					microui     & C    & MIT             & 2018 &  5 120 \\
					raygui      & C    & Zlib            & 2014 &  4 409 \\\RowStyle[cell-space-bottom-limit=1pt]{}
					Gio         & Go   & MIT, Unlicense  & 2019 &  2 052 \\
				\hline
		\end{NiceTabular}
	\end{table}
	
	\subsection{Dear ImGui}
	
	% * Mrknout na hello imgui a imgui toolkit
	% * Zmínit docking branch
	% * Je to C++ nebo jen C?
	
	\subsection{egui}
	
	\subsection{Nuklear}
	
	\subsection{microui}
	
	\subsection{raygui}
	
	\subsection{Gio}
	
	% Zdroje
	\chapter*{Seznam použité literatury}
	\addcontentsline{toc}{chapter}{Seznam použité literatury}
	\printbibliography[heading=none]
	
	% Přílohy
	\appendix
	\chapter{Ukázkové kódy}
	
	\begin{code}
		\lstinputlisting[language=CppQt]{code/hello_counter_rmgui.cpp}
		\caption{Kód demonstrující přístup RMGUI s využitím knihovny Qt}
		\label{_tag_code_HelloCounterQt}
	\end{code}
	
	\begin{code}
		\lstinputlisting[language=CppImGui]{code/hello_counter_imgui.cpp}
		\caption{Kód demonstrující přístup IMGUI s využitím knihovny Dear ImGui}
		\label{_tag_code_HelloCounterImGui}
	\end{code}
	
\end{document}
